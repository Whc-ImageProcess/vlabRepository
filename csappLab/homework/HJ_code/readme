https://www.cnblogs.com/qingergege/p/5925811.html
在c语言中读取字符串有多种方法，比如scanf() 配合%s使用，但是这种方法只能获取一个单词，
即遇到空格等空字符就会返回。如果要读取一行字符串，比如：
I love BIT
这种情况，scanf()就无能为力了。这时我们最先想到的是用gets()读取.
gets()函数从标准输入（键盘）读入一行数据，所谓读取一行，就是遇到换行符就返回。
gets()函数并不读取换行符'\n',它会吧换行符替换成空字符'\0',作为c语言字符串结束的标志。
gets()函数经常和puts()函数配对使用，puts()函数用于显示字符串，并自动在字符串后面添加一个换行标志'\n'
gets()函数存在一个严重的缺陷，这个缺陷就是：它不会检查数组是否能够装的下输入行：
比如：
我们定义了一个数组char src[5],这时候我们调用gets(src)，来从标准输入读取字符串，
我们看到gets()函数的参数为数组名，我们都知道，
数组名就相当于一个指针，也就是数组的首地址。这时如果我们的输入大于5个字符，
比如 I love BIT,gets()函数会从src所指地址开始，依次填入每个字符，
但是src只分配了5个字节的空间，填满这五个空间后，gets()函数就会访问未被分配的内存空间，
如果这片空间已经存有数据，这时程序就会发生错误，而中断。
正式由于gets()函数的这个缺陷，在C99标准中，已经不再建议使用gets()函数，而在C11中更是直接抛弃了这个函数。
gets()被抛弃，那我们用什么来代替它的功能呢？
C11标准新增了gets_s()函数可以代替gets()函数，但是，该函数是stdio.h输入输出函数系类中的可选扩展，
因此，即使编译器支持C11标准，也有可能不支持gets_s()函数。
其实我们可以用c语言中的fgets()函数来代替gets()
我们先看一下函数原型声明：
char *fgets(char *buf, int bufsize, FILE *stream)；
注意一下第二个参数bufsize，这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。
我们知道fgets() 函数主要用于读取文件，如果要读取键盘，则stream参数应该为stdin，
需要注意的是，如果bufsize设置为n，那么fgets()函数最多读取n-1个字符，之所以用“最多”这个词是因为，
如果在之前遇到了换行符，fgets函数也会返回。
还有一点就是，fgets()函数会读取换行符（这一点和gets函数不同），
当读取结束后，fgets函数会为buf在末尾添加一个空字符作为字符串的结束。